#!/usr/bin/env python3
"""Generate lore content using LLM providers."""

import argparse
import json
import os
import re
import subprocess
import sys
import time
from pathlib import Path

SKOGAI_DIR = Path(__file__).parent.parent
ENTRIES_DIR = SKOGAI_DIR / "knowledge/expanded/lore/entries"
BOOKS_DIR = SKOGAI_DIR / "knowledge/expanded/lore/books"
PERSONAS_DIR = SKOGAI_DIR / "knowledge/expanded/personas"


def run_llm(prompt: str, provider: str, model: str) -> str:
    """Run LLM with specified provider."""
    if provider == "claude":
        result = subprocess.run(
            ["claude", "--print", prompt],
            capture_output=True,
            text=True
        )
        if result.returncode != 0:
            print(f"Claude CLI error (code {result.returncode}): {result.stderr}", file=sys.stderr)
        output = result.stdout.strip()
        if not output:
            print(f"Claude CLI returned empty response. stderr: {result.stderr}", file=sys.stderr)
        return output
    elif provider == "ollama":
        result = subprocess.run(
            ["ollama", "run", model, prompt],
            capture_output=True,
            text=True
        )
        return result.stdout.strip()
    elif provider == "openai":
        import requests
        api_key = os.environ.get("OPENAI_API_KEY") or os.environ.get("OPENROUTER_API_KEY")
        base_url = os.environ.get("OPENAI_BASE_URL", "https://openrouter.ai/api/v1")

        response = requests.post(
            f"{base_url}/chat/completions",
            headers={
                "Authorization": f"Bearer {api_key}",
                "Content-Type": "application/json"
            },
            json={
                "model": model,
                "messages": [{"role": "user", "content": prompt}],
                "max_tokens": 2048
            }
        )
        return response.json()["choices"][0]["message"]["content"]
    else:
        raise ValueError(f"Unknown provider: {provider}")


def get_latest_file(directory: Path) -> str:
    """Get the most recently created file in directory."""
    files = list(directory.glob("*.json"))
    if not files:
        return None
    latest = max(files, key=lambda f: f.stat().st_mtime)
    return latest.stem


def generate_entry(title: str, category: str, provider: str, model: str) -> str:
    """Generate a lore entry."""
    print(f"Generating lore entry: {title} ({category})")

    prompt = f"""Create a detailed lore entry about '{title}'. This should be high-quality fantasy/sci-fi lore content for a '{category}'.

Your response should include:
- Rich descriptive details
- Interesting connections to potential other lore elements
- Unique characteristics or features
- Historical significance if relevant

Write 2-3 paragraphs of rich, evocative content."""

    content = run_llm(prompt, provider, model)

    # Create entry using manage-lore.sh
    subprocess.run(
        [str(SKOGAI_DIR / "tools/manage-lore.sh"), "create-entry", title, category],
        check=True
    )

    # Get the new entry ID
    entry_id = get_latest_file(ENTRIES_DIR)
    entry_path = ENTRIES_DIR / f"{entry_id}.json"

    # Update with generated content
    with open(entry_path) as f:
        entry = json.load(f)

    entry["content"] = content
    entry["summary"] = f"Generated by {model}"

    with open(entry_path, "w") as f:
        json.dump(entry, f, indent=2)

    print(f"Created lore entry: {entry_id}")
    return entry_id


def generate_persona(name: str, description: str, provider: str, model: str) -> str:
    """Generate a persona with traits and voice."""
    print(f"Generating persona: {name}")

    prompt = f"""Generate personality traits and voice characteristics for a character named '{name}' who is '{description}'.

Format your response exactly like this:
TRAITS: trait1,trait2,trait3,trait4
VOICE: concise description of voice and speaking style

Be creative and make sure traits are comma-separated without spaces."""

    response = run_llm(prompt, provider, model)

    # Parse response
    traits = "mysterious,magical,enigmatic,wise"
    voice = "eloquent and mystical"

    for line in response.split("\n"):
        line = line.strip()
        if line.upper().startswith("TRAITS:"):
            traits = line.split(":", 1)[1].strip()
        elif line.upper().startswith("VOICE:"):
            voice = line.split(":", 1)[1].strip()

    # Create persona
    subprocess.run(
        [str(SKOGAI_DIR / "tools/create-persona.sh"), "create", name, description, traits, voice],
        check=True
    )

    persona_id = get_latest_file(PERSONAS_DIR)
    print(f"Created persona: {persona_id}")
    return persona_id


def generate_lorebook(title: str, description: str, entry_count: int, provider: str, model: str) -> str:
    """Generate a lorebook with entries."""
    print(f"Generating lorebook: {title}")
    print(f"Number of entries: {entry_count}")

    # Create the book
    subprocess.run(
        [str(SKOGAI_DIR / "tools/manage-lore.sh"), "create-book", title, description],
        check=True
    )

    book_id = get_latest_file(BOOKS_DIR)

    # Generate entry ideas
    prompt = f"""Generate {entry_count} unique and interesting lore entry titles for a fantasy/sci-fi world called '{title}'. {description}

Format your response as a numbered list like this:
1. [Category: place] The Crystal Caverns
2. [Category: character] Elder Moonwhisper
3. [Category: event] The Great Sundering

Categories MUST be one of: place, character, object, event, concept"""

    response = run_llm(prompt, provider, model)

    # Debug: show what we got
    if os.environ.get("DEBUG"):
        print(f"LLM Response:\n{response}\n---")

    # Parse entries - be flexible with format
    entries_created = 0
    for line in response.split("\n"):
        line = line.strip()
        if not line:
            continue

        # Match numbered lines
        match = re.match(r'^\d+\.\s*(.+)$', line)
        if not match:
            continue

        entry_text = match.group(1)

        # Extract category
        category = "custom"
        cat_match = re.search(r'\[Category:\s*([^\]]+)\]', entry_text, re.IGNORECASE)
        if cat_match:
            category = cat_match.group(1).strip().lower()
            # Remove category from title
            entry_title = re.sub(r'\[Category:\s*[^\]]+\]\s*', '', entry_text).strip()
        else:
            entry_title = entry_text

        if not entry_title:
            continue

        # Generate the entry
        entry_id = generate_entry(entry_title, category, provider, model)

        # Add to book
        subprocess.run(
            [str(SKOGAI_DIR / "tools/manage-lore.sh"), "add-to-book", entry_id, book_id],
            check=True
        )

        entries_created += 1
        print(f"Added entry '{entry_title}' to book")

    print(f"Lorebook {book_id} created with {entries_created} entries")
    return book_id


def link_persona_with_lore(persona_id: str, book_count: int, provider: str, model: str):
    """Link a persona with lore books."""
    # Get existing books
    result = subprocess.run(
        [str(SKOGAI_DIR / "tools/manage-lore.sh"), "list-books"],
        capture_output=True,
        text=True
    )

    books = re.findall(r'(book_[0-9_a-f]+)', result.stdout)[:book_count]

    # Generate more if needed
    if len(books) < book_count:
        # Get persona name
        result = subprocess.run(
            [str(SKOGAI_DIR / "tools/create-persona.sh"), "show", persona_id],
            capture_output=True,
            text=True
        )

        persona_name = "Unknown"
        for line in result.stdout.split("\n"):
            if "Persona:" in line:
                persona_name = line.split("Persona:")[1].strip().replace("===", "").strip()
                break

        new_book_id = generate_lorebook(
            f"{persona_name}'s Chronicles",
            f"A collection of lore relevant to {persona_name}",
            3,
            provider,
            model
        )
        books.append(new_book_id)

    # Link books
    for book_id in books:
        subprocess.run(
            [str(SKOGAI_DIR / "tools/manage-lore.sh"), "link-to-persona", book_id, persona_id],
            check=True
        )
        print(f"Linked book {book_id} to persona {persona_id}")


def main():
    parser = argparse.ArgumentParser(description="Generate lore content using LLM")
    parser.add_argument("command", choices=["entry", "persona", "lorebook", "link"],
                       help="Command to run")
    parser.add_argument("args", nargs="*", help="Command arguments")
    parser.add_argument("--provider", default=os.environ.get("LLM_PROVIDER", "ollama"),
                       help="LLM provider (ollama, claude, openai)")
    parser.add_argument("--model", default="llama3",
                       help="Model name for ollama/openai")

    args = parser.parse_args()

    if args.command == "entry":
        if len(args.args) < 2:
            print("Usage: entry <title> <category>")
            sys.exit(1)
        generate_entry(args.args[0], args.args[1], args.provider, args.model)

    elif args.command == "persona":
        if len(args.args) < 2:
            print("Usage: persona <name> <description>")
            sys.exit(1)
        generate_persona(args.args[0], args.args[1], args.provider, args.model)

    elif args.command == "lorebook":
        if len(args.args) < 2:
            print("Usage: lorebook <title> <description> [count]")
            sys.exit(1)
        count = int(args.args[2]) if len(args.args) > 2 else 3
        generate_lorebook(args.args[0], args.args[1], count, args.provider, args.model)

    elif args.command == "link":
        if len(args.args) < 1:
            print("Usage: link <persona_id> [book_count]")
            sys.exit(1)
        count = int(args.args[1]) if len(args.args) > 1 else 1
        link_persona_with_lore(args.args[0], count, args.provider, args.model)


if __name__ == "__main__":
    main()
